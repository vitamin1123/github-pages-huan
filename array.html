<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - arraycamera</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			let camera, scene, renderer;
			let mesh;
			const AMOUNT = 16;
			const encoder = new TextEncoder("gbk")
			var xhr = new XMLHttpRequest();
			var reader = new FileReader();
			const array16x16 = []; 
			for (let i = 0; i < 16; i++) {  
					
				array16x16[i] = [];  
				for (let j = 0; j < 16; j++) {  
					array16x16[i][j] = 0;  
				}  
			} 


			init();
			animate();
			
			
			const ranges = [
				[0xA1, 0xA9,  0xA1, 0xFE],
				[0xB0, 0xF7,  0xA1, 0xFE],
				[0x81, 0xA0,  0x40, 0xFE],
				[0xAA, 0xFE,  0x40, 0xA0],
				[0xA8, 0xA9,  0x40, 0xA0],
				[0xAA, 0xAF,  0xA1, 0xFE],
				[0xF8, 0xFE,  0xA1, 0xFE],
				[0xA1, 0xA7,  0x40, 0xA0],
			]
			const codes = new Uint16Array(23940)
			let i = 0

			
			for (const [b1Begin, b1End, b2Begin, b2End] of ranges) {
				for (let b2 = b2Begin; b2 <= b2End; b2++) {
					if (b2 !== 0x7F) {
					for (let b1 = b1Begin; b1 <= b1End; b1++) {
						codes[i++] = b2 << 8 | b1
					}
					}
				}
			}

			const str = new TextDecoder('gbk').decode(codes)

				// 编码表
			const table = new Uint16Array(65536)

			for (let i = 0; i < str.length; i++) {
				table[str.charCodeAt(i)] = codes[i]
			}
			await hzPrint('你');
			function stringToGbk(str) {
				const buf = new Uint8Array(str.length * 2)
				let n = 0

				for (let i = 0; i < str.length; i++) {
					const code = str.charCodeAt(i)
					if (code < 0x80) {
					buf[n++] = code
					} else {
					const gbk = table[code]
					buf[n++] = gbk & 0xFF
					buf[n++] = gbk >> 8
					}
				}
				return buf.subarray(0, n)
			}

			function hzkOffset(hz) {  
				
				const buffer1 = stringToGbk(hz);
				
				const q = buffer1[0]; 
				const w = buffer1[1]; 
				//console.log('buffer1:',buffer1,q,w) 
				
				return ((q - 161) * 94 + w - 161) * 32;  
			}  

			function fetchDataWithXHR(url) {  
				//console.log("fetchDataWithXHR")
				return new Promise((resolve, reject) => {  
					const xhr = new XMLHttpRequest();  
					xhr.open('GET', url, true); 
					xhr.responseType = 'blob'; 
					xhr.onload = function() {  
					if (xhr.status === 200) {  
						resolve(xhr.response); // 解析响应文本  
					} else {  
						reject(new Error(`Request failed.  Returned status of ${xhr.status}`));  
					}  
					};  
					xhr.onerror = function() {  
					reject(new Error('Network Error'));  
					};  
					xhr.send();  
				});  
			} 

			function readFileAsArrayBuffer(file) {  
					return new Promise((resolve, reject) => {  
						const reader = new FileReader();  
						reader.onload = function() {  
							resolve(reader.result);  
						};  
						reader.onerror = function() {  
							reject(reader.error);  
						};  
						reader.readAsArrayBuffer(file);  
					});  
			} 
			async function hzBuffer(hzstr) {  
				const buffers = [];
				const filePath = '..\\hzk16s';  
				
					try {  
						
						const fileContent = await fetchDataWithXHR(filePath);  
						for (let z of hzstr) { 
							const offset = hzkOffset(z);
							console.log('偏移量',offset);
							var result1 = await readFileAsArrayBuffer(fileContent);
							//reader.readAsArrayBuffer(fileContent)
							
								
							var buff2 = result1.slice(offset,offset+32)
							//console.log('result:',buff2 )
								
							buffers.push(buff2)
								 
							
							
						}  
					} catch (error) {  
						console.error('Error fetching data:', error);  
					}  
				 
					return buffers;
				// xhr.open('GET', filePath, true);
				// xhr.responseType = 'blob';
				// xhr.onload = function(){
				// 	if(xhr.status === 200) {
				// 		var fileContent = xhr.response; //blob 文件
				// 		for (let z of hzstr) { 
				// 			const offset = hzkOffset(z);
				// 			console.log('偏移量',offset);
				// 			reader.readAsArrayBuffer(fileContent)
				// 			reader.onload = function(){
								
				// 				var buff2 = this.result.slice(offset,offset+32)
				// 				console.log('result:',this.result,buff2 )
								
				// 				buffers.push(buff2)
				// 				return buff2
				// 			}
							
				// 		}
						
				// 	}
				// }
				// xhr.send()
				
				 
			} 
			
			async function hzPrint(hzstr) {  
				
				const buffers = await hzBuffer(hzstr);  
				//console.log('buffers:',buffers,typeof(buffers))
				for (let buffer of buffers) { 
					const int8View = new Int8Array(buffer)
					console.log('buffers里的buffer:',buffer) 
					for (let y = 0; y < 16; y++) {  
						for (let x = 0; x < 16; x++) {  
							const bitIndex = (y * 2) + Math.floor(x / 8);  
							const bitMask = Array.from({length: 8}, (_, index) => Math.pow(2, (7-index))); 
							console.log("bitIndex",int8View[bitIndex]);
							if ((int8View[bitIndex] & bitMask[x%8]) !== 0) {  
								array16x16[y][x] = 1;
								//console.log(".");  
							} else {  
								array16x16[y][x] = 0;
								//console.log(" ");  
							}  
			
							if (x === 15) {  
								//console.log("\n");  
							}  
						}  
					}  
					//console.log("\n");  
				} 
				console.log("16*16: ",array16x16) 
			} 
			
			function init() {

				const ASPECT_RATIO = window.innerWidth / window.innerHeight;

				const WIDTH = ( window.innerWidth / AMOUNT ) * window.devicePixelRatio;
				const HEIGHT = ( window.innerHeight / AMOUNT ) * window.devicePixelRatio;

				const cameras = [];

				for ( let y = 0; y < AMOUNT; y ++ ) {

					for ( let x = 0; x < AMOUNT; x ++ ) {

						const subcamera = new THREE.PerspectiveCamera( 40, ASPECT_RATIO, 0.1, 10 );
						subcamera.viewport = new THREE.Vector4( Math.floor( x * WIDTH ), Math.floor( y * HEIGHT ), Math.ceil( WIDTH ), Math.ceil( HEIGHT ) );
						subcamera.position.x = ( x / AMOUNT ) - 0.5;
						subcamera.position.y = 0.5 - ( y / AMOUNT );
						subcamera.position.z = 1.5;
						subcamera.position.multiplyScalar( 2 );
						subcamera.lookAt( 0, 0, 0 );
						subcamera.updateMatrixWorld();
						cameras.push( subcamera );

					}

				}

				camera = new THREE.ArrayCamera( cameras );
				camera.position.z = 3;

				scene = new THREE.Scene();

				scene.add( new THREE.AmbientLight( 0x999999 ) );

				const light = new THREE.DirectionalLight( 0xffffff, 3 );
				light.position.set( 0.5, 0.5, 1 );
				light.castShadow = true;
				light.shadow.camera.zoom = 4; // tighter shadow map
				scene.add( light );

				const geometryBackground = new THREE.PlaneGeometry( 100, 100 );
				const materialBackground = new THREE.MeshPhongMaterial( { color: 0x000066 } );

				const background = new THREE.Mesh( geometryBackground, materialBackground );
				background.receiveShadow = true;
				background.position.set( 0, 0, - 1 );
				scene.add( background );

				const geometryCylinder = new THREE.CylinderGeometry( 0.5, 0.5, 1, 32 );
				const materialCylinder = new THREE.MeshPhongMaterial( { color: 0xffdfd4 } );

				mesh = new THREE.Mesh( geometryCylinder, materialCylinder );
				mesh.castShadow = true;
				mesh.receiveShadow = true;
				scene.add( mesh );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const ASPECT_RATIO = window.innerWidth / window.innerHeight;
				const WIDTH = ( window.innerWidth / AMOUNT ) * window.devicePixelRatio;
				const HEIGHT = ( window.innerHeight / AMOUNT ) * window.devicePixelRatio;

				camera.aspect = ASPECT_RATIO;
				camera.updateProjectionMatrix();

				for ( let y = 0; y < AMOUNT; y ++ ) {

					for ( let x = 0; x < AMOUNT; x ++ ) {

						const subcamera = camera.cameras[ AMOUNT * y + x ];

						subcamera.viewport.set(
							Math.floor( x * WIDTH ),
							Math.floor( y * HEIGHT ),
							Math.ceil( WIDTH ),
							Math.ceil( HEIGHT ) );

						subcamera.aspect = ASPECT_RATIO;
						subcamera.updateProjectionMatrix();

					}

				}

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				mesh.rotation.x += 0.005;
				mesh.rotation.z += 0.01;

				renderer.render( scene, camera );

				requestAnimationFrame( animate );

			}

		</script>

	</body>
</html>
